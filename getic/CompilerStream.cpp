//----------------------------------------------------------------------------------------
// Unauthorized use or duplication is strictly prohibited.
// Copyright Zalsoft Inc 1999-2004.  
//// Author: Marius C of Zalsoft Inc 2000-2004
//----------------------------------------------------------------------------------------
#include "stdafx.h"
#include "z-edmap.h"
#include "Compiler.h"
#include "Scene.h"
#include "z_ed2Doc.h"
#include "BspTree.h"
#include "z_ed3View.h"
#include "DlgCompProgress.h"
#include "MainFrm.h"
#include "..\\_include\\BspFIleStr.h" 
#include "LightBulb.h"
#include "TriggerItem.h"
#include "ScriptItem.h"
#include "StartPlayItem.h"
#include "Scene.h"
#include "GameItem.h"
#include "BigTerrain.h"
#include "BzipCompressor.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#ifdef _DEBUG
struct Srgb3
{
    BYTE    r;
    BYTE    g;
    BYTE    b;
};
#endif //

//--|     Compiler::Save|-----------------------------------------------------------------
BOOL     Compiler::Save(LPCTSTR pszFileName)
{
    REDIR();
    map<int,int>        texids;
    map<int,int>        sndids;
    FlStream                fw;
    char                testcd[256]    ;

    _getcwd(testcd,256);
    

    if(fw.Open(pszFileName,"wb") == 0)
    {
        LOG(E_COMP, "Error: CMPL:%d Error: saving file '%s' ", GetLastError(), pszFileName);
        return FALSE;
    }
    
    WriteHeader(fw);
    WriteGameInit(fw);
    WriteSceneInfo(fw);
    if(_bSaveSkyDom)        WriteSkyDomInfo(fw);
    if(_bSaveImages)        WriteImages(fw);
    WriteTexInfo(texids, fw);   // texids
    if(_bLightMaps)         WriteLMInfoAndData(fw);
    if(_bSaveCats)		    WritItemsCathegory(fw);
    if(_bSaveImages)        WriteSounds(fw);
    WriteSndInfo(sndids, fw);
    WriteItemsInfo(sndids,texids,fw);
    WriteBsps(texids, fw);
    WriteMotions(fw);
    if(_bSaveBigTerrain)    WriteTerrain(fw, texids);
	WriteScripts(fw);
	if(_bSaveImages)		WriteScriptsData(fw);
    WriteDetails(fw);
    
    BTF_Section se = {SECT_EOF,0};
    fw.Write(se,"SECT_EOF");
    fw.Close();
    return TRUE;
}

//--|    Compiler::WriteHeader|-----------------------------------------------------------
void    Compiler::WriteHeader(FlStream& fw)
{
    BTF_Header    fh;
    
    _tcscpy(fh.sig,GeticGeometryBeamTree);
    fh.version  = BSP_VERSION1 ;
    _tcscpy(fh.comments, "Generated by 'Getic 3D");
    ::CoCreateGuid((GUID*)&fh.uuid);

    fw.Write(fh, "BTF_Header");
}

//--|    Compiler::WriteImages|-----------------------------------------------------------
void    Compiler::WriteGameInit(FlStream& fw)
{
    BTF_Section  s = {SECT_INITGAME, 0};
    fw.Write(s, "SECT_INITGAME");
}

//--|    Compiler::WriteImages|-----------------------------------------------------------
void    Compiler::WriteImages(FlStream& fw)
{
    BTF_TextureRGB     srgb;
    char               sFullPath[256];
    int                toWrite = 0;
    
    TexSys::iterator bt = GTexSys.begin();
    TexSys::iterator et = GTexSys.end();
    for(;bt != et; bt++)
    {
        #ifdef _DEBUG
            const char* p = (*bt).first.c_str();
        #endif //_DEBUG
        if((*bt).first.find("@L")==-1)   // skip lmaps
            ++toWrite;
    }
    
    
    BTF_Section  s = {SECT_TEXRGB, toWrite};
    BYTE dBits[12] = {255,0,0, 0,255,0, 0,0,255, 255,0,255};

    fw.Write(s, "SECT_TEXRGB");
    int start = fw.GetPos();
    
    int   tIndex = 0;
    bt = GTexSys.begin();
    et = GTexSys.end();
    for(;bt != et; bt++)
    {
        do  //scope for TexHandler
        {
            // writes the bitmap
            _tcscpy(sFullPath,(*bt).first.c_str());
            if(sFullPath[0]=='&')
                _tcscpy(sFullPath,sFullPath+1);
            char* pdash = strchr(sFullPath,'?');
            if(pdash)*pdash=0;

            TexHandler  th;
            if(sFullPath[0] !='@' && th.LoadFile(sFullPath, 0))
            {
                srgb.index = tIndex;
                srgb.bpp   = th.n_bpp;
                srgb.cx    = th.n_x;
                srgb.cy    = th.n_y;
                srgb.sz    = th.n_size;
				srgb.flags = (*bt).second.hTex.glTarget;
                
                
                fw.Write(srgb,"BTF_TextureRGB");
                fw.Write(th.Buffer(), th.n_size);

            }
            else
            {
                // skip all light maps(). write the tex which was not found
                // as default texture
                if(_tcsncmp(sFullPath,"@L",2))
                {
                    srgb.index = tIndex;
                    srgb.bpp   = 3;
                    srgb.cx    = 2;
                    srgb.cy    = 2;
                    srgb.sz    = 2*2*3;
                    srgb.flags = TEX_NORMAL;
                    fw.Write(srgb, "BTF_TextureRGB");
                    fw.Write(dBits, sizeof(dBits));
                }
            }
            th.Reset();
            
        }while(0);
        ++tIndex;
    }
    KeepSecttions(start, fw.GetPos(), s, fw);
}

//--| Compiler::WriteTexInfo|-------------------------------------------------------------
void Compiler::WriteTexInfo(map<int,int>& texids, FlStream& fw)
{
    char        sFullPath[256];
    char        sExt[32];
    char        sDummy[256];
    int         cntTex  =   0;
    BTF_Section s       =   {SECT_TEXINFO, GTexSys.size()};
    
    fw.Write(s, "SECT_TEXINFO");
    int start = fw.GetPos();
    
    TexSys::iterator bt = GTexSys.begin();
    TexSys::iterator et = GTexSys.end();

    texids[_dumptex] = -1;
    for(;bt != et; bt++)
    {
        BTF_TextureInfo ti = {TEX_NORMAL};

        Texture& tex  = (*bt).second;
        texids[tex.hTex.hTex] = cntTex++;         //
        
        ::memset(sFullPath,0,sizeof(sFullPath));
        ::_tcsncpy(sFullPath,(*bt).first.c_str(), MAX_SLEN-2);
        char* pdash = strchr(sFullPath,'?');
        if(pdash)*pdash=0;

        
        if(_tcslen(sFullPath) > (MAX_SLEN-4))
        {
            LOGERR(E_COMP, V0, MKSTR("Texture: '%s' was truncated to %d characters", sFullPath, MAX_SLEN));
        }

        ::_tsplitpath(sFullPath, sDummy, sDummy, ti.texname, sExt);
        ::_tcscat(ti.texname, sExt);

        // masked permanent texture
        if(ti.texname[0]=='&')
            _tcscpy(ti.texname,ti.texname+1);
        
        ti.creaFlags = tex.hTex.glTarget;   // kind
        
        fw.Write(ti, "BTF_TextureInfo");
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}

//--|    Compiler::WriteScripts|----------------------------------------------------------
void    Compiler::WriteScripts(FlStream& fw)
{
    vvector<ScriptItem*>* ps = DOC()->_scene.GetScripts();
    int nScripts             = ps->size();
    
    BTF_Section     s = {SECT_SCRINFO, nScripts};
    fw.Write(s, "SECT_SCRINFO");
    int             start  = fw.GetPos();
    
    FOREACH(vvector<ScriptItem*>, (*ps) ,ppScr)
    {
        do{
            ScriptItem* pSi = *ppScr;
            BTF_ScrInfo bsi = {0};
            
            
            ASSERT(pSi->_script.length()!=0);
            _tcscpy(bsi.scrName ,pSi->_script.c_str());
            
            fw.Write(bsi, "BTF_ScrInfo");
        }while(0);
        
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}

//--|    Compiler::WriteScriptsData|------------------------------------------------------
void    Compiler::WriteScriptsData(FlStream& fw)
{
    vvector<ScriptItem*>* ps = DOC()->_scene.GetScripts();
    int nScripts             = ps->size();
    
    BTF_Section     s = {SECT_SCRDATA, nScripts};
    fw.Write(s, "SECT_SCRDATA");
    int start       = fw.GetPos();
    
    FOREACH(vvector<ScriptItem*>,(*ps) ,ppScr)
    {
        do{
            long  lf  = 0;
            ScriptItem* pSi = *ppScr;
            // dump the script file into the bsp file
            FlStream fscr;
            if(fscr.Open(pSi->_script.c_str(),"rb"))
            {
                lf = fscr.Getlength();
                BYTE* pBy = new BYTE[lf];
                if(pBy)
                {
                    fscr.Read(pBy, lf);
                    
                    fw.Write(lf, "unsigned char");
                    fw.Write(pBy, lf);
                    
                    delete[] pBy;
                }
                fscr.Close();
            }else
            {
                fw.Write(lf,"unsigned char");
            }
            
        }while(0);
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}

//--|    Compiler::WriteSndInfo|----------------------------------------------------------
void    Compiler::WriteSndInfo(map<int,int>& sndInfo, FlStream& fw)
{
    
    vvector<CSoundItem*>*  psnds = SCENE().GetSounds();
    
    BTF_Section     s = {SECT_SNDINFO, psnds->size()};
    fw.Write(s, "SECT_SNDINFO");
    int start = fw.GetPos();
    
    FOREACH(vvector<CSoundItem*>,  (*psnds), ppsnd)
    {
        CSoundItem* psnd = *ppsnd;
        BTF_SndInfo  bsi;
        
        bsi.flags   = psnd->_flags;
        bsi.radius  = psnd->_radius;
        bsi.volume  = psnd->_volume;
        _tcscpy(bsi.sndname,psnd->_soundfile.c_str());
        
        fw.Write(bsi,"BTF_SndInfo");
    }
    
    KeepSecttions(start,fw.GetPos(), s, fw);
}


//--|    Compiler::WriteSounds|-----------------------------------------------------------
void    Compiler::WriteSounds(FlStream& fw)
{
    vvector<CSoundItem*>*  psnds = SCENE().GetSounds();
    
    BTF_Section     s = {SECT_SNDFILE, psnds->size()};
    fw.Write(s,"SECT_SNDFILE");
    int start = fw.GetPos();
    
    FOREACH(vvector<CSoundItem*>,  (*psnds), ppsnd)
    {
        CSoundItem* psnd = *ppsnd;
        FileWrap    fw2;
        BTF_SndFile  sw = {0};
        
        if(fw2.Open(MKSTR("res\\%s",psnd->_soundfile.c_str()),"rb"))
        {
            sw.length = fw2.Getlength();
            _tcscpy(sw.sndname,psnd->_soundfile.c_str());
            
            fw.Write(sw,"BTF_SndWAW");
            
            BYTE    tmpBuff[256];
            long    checkSum = 0;
            long    lr ;
            while(1)
            {
                lr = fread(tmpBuff,1,256,fw2._pf);

                if(lr)
                  fw.Write(tmpBuff,lr);
                
                checkSum+=lr;
                
                if(feof(fw2._pf))
                  break;
            }
            assert(checkSum == sw.length);
            fw2.Close();
        }
    }
    //and BYTE*
    
    KeepSecttions(start,fw.GetPos(), s, fw);
}



//--|    Compiler::WriteLMInfoAndData|----------------------------------------------------
void    Compiler::WriteLMInfoAndData(FlStream& fw)
{

    DWORD         lmIndex  = 0;
    BTF_Section     s = {SECT_LMINFO, _lmProc._lMaps.size()};
    fw.Write(s,"SECT_LMINFO");
    int start = fw.GetPos();
#ifdef _DEBUG
    vvector<DWORD>    offsets;
#endif //
    
    FOREACH(vvector<LmSizeBuff*>, _lmProc._lMaps, ppLmi)
    {
        LmSizeBuff*     pLmi = *ppLmi;
        BTF_LmapInfo btLmi;
        
        btLmi.index   = lmIndex;      // index in buff offset from start (write light map buffers)
        btLmi.bpp     = pLmi->bpp;
        btLmi.flags   = pLmi->flags;
        //
        // BSP version 201
        // tmax 256 x 256 lightmap size bitmap
        //
        btLmi.xsz     = ( ((BYTE)pLmi->realsz.cx) << 8 )  | ((BYTE)(pLmi->sz.cx));   
        btLmi.ysz     = ( ((BYTE)pLmi->realsz.cy) << 8 )  | ((BYTE)(pLmi->sz.cy));
        fw.Write(btLmi,"BTF_LmapInfo");
        
        //
        // update where this buffer is save from the begining of lmaps buffers
        //
        pLmi->index = lmIndex;

        if(Compiler::PCompiler->_lmConst)
            lmIndex     += pLmi->realsz.cx * pLmi->realsz.cy * pLmi->bpp; // offset by real xy
        else
            lmIndex     += pLmi->sz.cx * pLmi->sz.cy * pLmi->bpp; // offset by real xy

#ifdef _DEBUG
        offsets.push_back(lmIndex);
#endif //
    }
    
    KeepSecttions(start,fw.GetPos(), s, fw);
    //
    // save the buffers
    //
    BTF_Section     s1 = {SECT_LMRGB, lmIndex};
    fw.Write(s1,"SECT_LMRGB");
    start = fw.GetPos();
    
    //
    // write light map buffers
    //
    long checksz = 0;
    int   dstOff  = 0;
    DWORD accDstOffs = 0;

    if(Compiler::PCompiler->_lmConst)
    {
        
        //
        // write only the populated data to save space. from [0 - pLmi->realSize)
        //
        //          __________(lightmap image size / @compiler options)
        //         |          |
        //         |   red    |
        //         |___(lmxy) |
        //         | lm|      |      we save only lm but when lm has to be build
        //         |___|______|      we gen whole lmp size couse the tex coord 
        //                           on any poly were scalled there. 

        //int   bpp;
        BYTE* pb   = new BYTE[256*256*3]; // buff enough to fit the lm
#ifdef _DEBUG
        Srgb3*          prgb3;
        Srgb3*          prgb3o = (Srgb3*)pb;    
        vvector<DWORD>::iterator itofs = offsets.begin();
#endif //
        
        FOREACH(vvector<LmSizeBuff*>, _lmProc._lMaps, ppLmi)
        {
            LmSizeBuff*     pLmi = *ppLmi;
#ifdef _DEBUG
            prgb3 = (Srgb3*)pLmi->pBuff;
#endif //
            SIZE&           realsz = pLmi->realsz;
            dstOff  = 0;
#ifdef _DEBUG
            DWORD& curoff = *(itofs++);
#endif //
            memset(pb, 0, pLmi->sz.cx*pLmi->sz.cy*pLmi->bpp);
            for(int y=0;y < realsz.cy; ++y)    
            {
                for(int x=0; x < realsz.cx ; ++x)    
                {
                    BYTE*  pCelSrc = &pLmi->pBuff[y * (pLmi->sz.cx*pLmi->bpp) + (x*pLmi->bpp)];
                    BYTE*  pCelDst =          &pb[y * (realsz.cx*pLmi->bpp) +   (x*pLmi->bpp)];

                    for(int rgb=0;rgb < pLmi->bpp; rgb++)
                    {
                        pCelDst[rgb] = pCelSrc[rgb];
                    }
                    dstOff += pLmi->bpp;
                }
            }
            accDstOffs += dstOff;
#ifdef _DEBUG
            assert(curoff == accDstOffs);
            assert(dstOff == pLmi->realsz.cx * pLmi->realsz.cy * pLmi->bpp);
#endif //            
            
            
            fw.Write((void*)pb, dstOff);
        }
        
        delete[] pb;
    }
    else
    {
        accDstOffs += 0;
#ifdef _DEBUG
        vvector<DWORD>::iterator itofs = offsets.begin();
#endif //
        FOREACH(vvector<LmSizeBuff*>, _lmProc._lMaps, ppLmi)
        {
            LmSizeBuff*     pLmi = *ppLmi;
            SIZE rlsz = pLmi->realsz; 
#ifdef _DEBUG
            DWORD& curoff = *(itofs++);
#endif //            
            pLmi->realsz = pLmi->sz;

            dstOff = pLmi->sz.cx * pLmi->sz.cy * pLmi->bpp;
            accDstOffs += dstOff;
            assert(curoff == accDstOffs);
            fw.Write((void*)pLmi->pBuff, dstOff);
            pLmi->realsz = rlsz;
        }
    }
    KeepSecttions(start,fw.GetPos(), s1, fw);
}

//--|    Compiler::WriteV3s|--------------------------------------------------------------
void    Compiler::WriteV3s(vvector<V3>& vertexPool,FlStream& fw, DWORD sect)
{
    BTF_Section     s = {sect, vertexPool.size()};

    fw.Write(s,"SECT_V3");

    int start = fw.GetPos();
    FOREACH(vvector<V3>,vertexPool,ppv)
    {
        fw.Write(*ppv);
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}

//--|    Compiler::WritePlanes|-----------------------------------------------------------
void    Compiler::WritePlanes(vvector<Plane>& allPlanes, FlStream& fw, DWORD sect)
{
    BTF_Section     s = {sect, allPlanes.size()};

    fw.Write(s,"SECT_PLANES");
    int start = fw.GetPos();
    FOREACH(vvector<Plane>, allPlanes, pPlane)
    {
        BTF_Plane   plan;
        
        plan.dist = pPlane->_c;
        plan.normal = pPlane->_n;

        fw.Write(plan,"BTF_Plane");
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}

//--|    Compiler::WriteNodes|------------------------------------------------------------
void    Compiler::WriteNodes(vvector<CMiniNode*>& allNodes, FlStream& fw, DWORD sect)
{
    BTF_Section     s = {sect, allNodes.size()};

    fw.Write(s,"SECT_NODES");
    int start = fw.GetPos();
    
    FOREACH(vvector<CMiniNode*>, allNodes, ppNode)
    {
        CMiniNode* pNode = *ppNode;
        
        BTF_Node    bn;
        
        bn.nodeidx[0]  = pNode->_nodeidx[0] >=0 ? pNode->_nodeidx[0] + ((CBspTree*)pNode->_pBsp)->_nodeStartIdx:-1;
        bn.nodeidx[1]  = pNode->_nodeidx[1] >=0 ? pNode->_nodeidx[1] + ((CBspTree*)pNode->_pBsp)->_nodeStartIdx:-1;
        bn.idxParent   = pNode->_idxParent  >=0 ? pNode->_idxParent  + ((CBspTree*)pNode->_pBsp)->_nodeStartIdx:-1;
        bn.leafIdx     = pNode->_leafIdx    >=0 ? pNode->_leafIdx    + ((CBspTree*)pNode->_pBsp)->_leafStartIdx:-1;
        bn.planeIdx    = pNode->_planeIdxFinal;
        bn.flags       = pNode->_nodeflags;
        bn.bbox        = pNode->_bbox;
        bn.areavis     = pNode->_zonearea;
        
        fw.Write(bn,"BTF_Node");
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}

//--|    Compiler::WriteLeafs|------------------------------------------------------------
void    Compiler::WriteLeafs(vvector<CLeaf*>& allLeafs,   FlStream& fw, DWORD sect)
{
    BTF_Section     s = {sect, allLeafs.size()};

    fw.Write(s,"SECT_LEAFS");
    int start = fw.GetPos();
    
    FOREACH(vvector<CLeaf*>,allLeafs, ppLeaf)
    {
        CLeaf*      pLeaf = *ppLeaf;
        CBspTree*   pTree = ((CBspTree*)pLeaf->_pBsp);
        BTF_Leaf        bl;
        
        if(pTree->IsMainModel())
            bl.flags     = pLeaf->_content;
        else
            bl.flags     = pTree->_treeprops;

        bl.firstPoly = pLeaf->_polyIdx     + pTree->_polyStartIdx;
        bl.polys     = pLeaf->_nPolys;

        bl.defLumin  = pLeaf->_ilum;
        bl.nodeIdx   = pLeaf->_idxNodeThis + pTree->_nodeStartIdx;
        bl.pvxIdx    = pLeaf->_pvsIdx;
        bl.portals   = 0;//pLeaf->_portIdxes.size(); not anymore  duplicted info
        bl.models    = 0;// pLeaf->_iModIndex.size(); //not anymore (done in engine)
        bl.firstItem = 0;
        bl.items     = 0;
        bl.areavis   = pLeaf->_zonearea;
        fw.Write(bl,"BTF_Leaf");

        /*
        FOREACH(vvector<int>, pLeaf->_portIdxes, pixx)   // portals
            fw.Write(*pixx);
        FOREACH(vvector<int>,  pLeaf->_iModIndex, pixx) // models
            fw.Write(*pixx);
        */
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}

//--|    Compiler::WriteModels|-----------------------------------------------------------
void    Compiler::WriteModels(FlStream& fw, DWORD sect)
{
    BTF_Section     s = {sect, _bTrees.size()};
    fw.Write(s,"SECT_MODELS");
    int start = fw.GetPos();
    
    FOREACH(vvector<CBspTree*>, _bTrees, ppTree)
    {
        CBspTree*   pTree = *ppTree;
        BTF_ModelInfo bi;
#pragma message("detail material content")
        bi.flags        = pTree->_treeflags;//material
        bi.props        = pTree->_treeprops;
        bi.index        = pTree->_thisIdx;
        bi.firstNode    = pTree->_nodeStartIdx;
        bi.nodes        = pTree->_nodesPtr.size();
        bi.firstLeaf    = pTree->_leafStartIdx;
        bi.leafs        = pTree->_leafs.size();
        bi.firstPoly    = pTree->_polyStartIdx;
        bi.polys        = pTree->_polys.size();
        bi.firstPortal  = 0;
        bi.portals      = (pTree->_prtProc) ? pTree->_prtProc->_portals.size() : 0;
        bi.pvs          = pTree->IsMainModel() ? _pvsPrc._cPvss : 0;
        
        bi.dynamicIdx   = pTree->_motionsIdx;
        bi.unused       = 0;
        bi.userVals[0]  = 1; //rotation
        bi.userVals[1]  = pTree->_rotSteps.x;
        bi.userVals[2]  = pTree->_rotSteps.y;
        bi.userVals[3]  = pTree->_rotSteps.z;
        bi.areavis      = pTree->_zoneareea;
       
        _tcscpy(bi.name, pTree->_name);
        fw.Write(bi, "BTF_ModelInfo");
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}

//--|    Compiler::WritePortals|----------------------------------------------------------
void    Compiler::WritePortals(FlStream& fw)
{
    BTF_Section     s = {SECT_PORTALS, _portPrc._portals.size()};

    fw.Write(s, "SECT_PORTALS");
    int start = fw.GetPos();
    
    FOREACH(vvector<Portal>, _portPrc._portals, pPort)
    {
        BTF_Portal  bp;
        
        bp.planeidx = pPort->_planeIdx;
        bp.bLeaf    = pPort->_sideLIdx[0];
        bp.fLeaf    = pPort->_sideLIdx[1];
        bp.vxes     = pPort->_vxes.size();
        
        fw.Write(bp,"BTF_Portal");
        FOREACH(vvector<V3>, pPort->_vxes, ppv)
               fw.Write(*ppv);
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}

//--|    Compiler::WritePvs|--------------------------------------------------------------
void    Compiler::WritePvs(FlStream& fw)
{
	if(_pvsPrc._pvs)
	{
		BTF_Section     s = {SECT_PVS, _pvsPrc._cPvss};
		fw.Write(s,"SECT_PVS");
		int start = fw.GetPos();
    
		fw.Write(_pvsPrc._pvs,_pvsPrc._cPvss);
    
		KeepSecttions(start,fw.GetPos(), s, fw);
	}
}

//--|    Compiler::WritePolys|------------------------------------------------------------
void    Compiler::WritePolys(vvector<Poly*>& allPolys,
                            map<int,int>& texids,
                            FlStream& fw, DWORD sect)
{
    BTF_Section     s = {sect, allPolys.size()};
    fw.Write(s,"SECT_POLYS");
    int start = fw.GetPos();
    
    
    
    FOREACH(vvector<Poly*>, allPolys, ppPoly)
    {
        Poly* pPoly = *ppPoly;
        
        #ifdef _DEBUG
            const char* pt = GTexSys.GetTexName(pPoly->GetHtex(GUtex));
        #endif //
        
        BTF_Poly       bPoly;

        bPoly.planeIdx  = pPoly->_planeIdxFinal;
        bPoly.flags     = pPoly->_polyprops;
        bPoly.flags2    = pPoly->_polyflags2;

        bPoly.colorS    = pPoly->_colorS;
        bPoly.colorD    = pPoly->_colorD;
        bPoly.colorE    = pPoly->_colorE;
        bPoly.shiness   = pPoly->_shiness;  

        bPoly.tanimA    = pPoly->_tanimA;
        
        // lmindex in saved lnmap buffer
        bPoly._texp.combine = pPoly->Combine();
        pPoly->GetTexs().GetTextureInts(bPoly._texp.textures, bPoly._texp.texApply);

        for(int t=0; t<4; t++)
        {
            if(t==1)continue;
            if(texids.find(bPoly._texp.textures[t]) != texids.end())
            {
                bPoly._texp.textures[t] = texids[bPoly._texp.textures[t]];
                bPoly._texp.combine |= (1<<t);
            }
            else
            {
                bPoly._texp.textures[t] = -1;
            }
        }
        

        #pragma message ("custom light map")
        if(bPoly.flags & FACE_CUSTLM)     
        {
            bPoly._texp.textures[1]   = texids[pPoly->GetHtex(TX_LM)];
            bPoly._texp.combine |= 2;
        }
        else
        {
            bPoly._texp.textures[1]   = pPoly->_lmInfo._lmIndex;
            bPoly._texp.combine |= 2;
        }
        

        //
        // light map axees for the attached light map info.
        //
        bPoly.lmAxes[0] = pPoly->_lmInfo._lmAxes[0];
        bPoly.lmAxes[1] = pPoly->_lmInfo._lmAxes[1];
        bPoly.lmAxes[2] = pPoly->_lmInfo._lmAxes[2];
        
        bPoly.bump       =  pPoly->_bump     * 100;
        bPoly.friction   =  pPoly->_friction * 100;

        //
        // store original brush id in order to rec original geom
        // keep it we may need to reconstruct from bsp orig lev file
        //
        
        bPoly.vxCount   = pPoly->_vtci.size();
        bPoly.brIdx     = pPoly->_pBrush->_unicID;
        if(!pPoly->_pBrush->IsSolid())
          bPoly.brIdx|=(IS_CUT_BRUSH);             // original brush is a cut brush (-1)
        
        
        fw.Write(bPoly, "BTF_Poly");
        
        FOREACH(vvector<Vtx2>, pPoly->_vtci, pVertex)
        {
            BTF_Vertex plv;
            
            plv.vxIdx = pVertex->_index;
            plv.tc0   = pVertex->_uv[TX_0];
            plv.tc1   = pVertex->_uv[TX_LM];
            plv.tc2   = pVertex->_uv[TX_1]; 
            plv.tc3   = pVertex->_uv[TX_2]; 

            plv.clr   = pVertex->_rgb;
            fw.Write(plv,"BTF_Vertex");
        }
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}
//--|    Compiler::WriteBsps|-------------------------------------------------------------
void    Compiler::WriteBsps(map<int,int>& texids, FlStream& fw)
{
    vvector<V3>              vertexPool(32768); //minimize mem fragmentation
    vvector<Plane>           allPlanes(4096);
    vvector<CMiniNode*>      allNodes(4096);
    vvector<Poly*>           allPolys(8912);
    vvector<CLeaf*>          allLeafs(4096);
    vvector<map<int,int>* >  remapIdx(512);
    
    
    //---------------vertexex pool ---------------------------
    // collect al vertexes together
    int iCount = 0;
    FOREACH(vvector<CBspTree*>, _bTrees, ppTree)
    {
        iCount+=(*ppTree)->AddUniqueVertexes(vertexPool);
    }
    LOG(E_COMP, "BSP: Vertex pool packed at %d%% ",100*(iCount / vertexPool.size()));
    
    //---------------planes pool ---------------------------
    // collect al planes in main bsp tree planes collection
    FOREACH(vvector<CBspTree*>, _bTrees, ppTree)
    {
        map<int,int>*    plMap = new map<int,int>();
        (*ppTree)->AddUniquePlane(allPlanes, *plMap);
        remapIdx << plMap;
    }
    
    // reindex all plane references from subsequent trees
    iCount = 0;
    FOREACH(vvector<CBspTree*>, _bTrees, ppTree)
    {
        (*ppTree)->ReindexPlanes( *(remapIdx[iCount++]));
    }
    remapIdx.deleteelements();
    
    //------------------polys/nodes/leafs  ------------------------
    FOREACH(vvector<CBspTree*>, _bTrees, ppTree)
    {
        (*ppTree)->CollectPNL(allPolys, allNodes, allLeafs);
    }
    
    WriteV3s(vertexPool,fw, SECT_V3);
    WritePlanes(allPlanes,fw,SECT_PLANES);
    WritePolys(allPolys,texids, fw,SECT_POLYS);
	WriteNodes(allNodes,fw,SECT_NODES);
    WriteLeafs(allLeafs,fw,SECT_LEAFS);
    WriteModels(fw,SECT_MODELS);
    WritePvs(fw);
    if(_bSavePortals)
    {
        WritePortals(fw);
    }
}


//--|    Compiler::WriteSceneInfo|--------------------------------------------------------
void    Compiler::WriteSceneInfo(FlStream& fw)
{
    BTF_Section     s = {SECT_SCENE,1};
    BST_SceneInfo   si;
    
    si.lightMapAspect = this->_lmConst;
    si.lightMappowof2 = this->_lmpowof2;

    int start = fw.GetPos();
    fw.Write(s,"SECT_SCENE");

    start = fw.GetPos();
    Scene& scen = SCENE();
    
    ::memcpy(&si, &scen._si, sizeof(si));
    si.sceneSpash=-1;

    if(si.sceneLogoFile[0])
    {
        FileWrap fw;
        if(fw.Open(si.sceneLogoFile,"rb"))
        {
            size_t length = fw.Getlength();
            fw.Close();
            si.sceneSpash      = 0;

            SBytes* bsect       = new SBytes();
            bsect->offset       = 0;
            bsect->ptr          = new BYTE[128];
            bsect->stype        = SBytes::S_IMAGE;
            bsect->size         = -128; //reference
            ::_tcscpy((char*)bsect->ptr, si.sceneLogoFile);
            si.sceneSpash       = 0;
        }
    }
    fw.Write(si,"BST_SceneInfo");
    KeepSecttions(start,fw.GetPos(), s, fw);
}


//--|    Compiler::WriteSkyDomInfo|-------------------------------------------------------
void    Compiler::WriteSkyDomInfo(FlStream& fw)
{
    if(_bTrees.size()==0)
        return;
    BTF_Section s = {SECT_SKYDOM, 1};
    BTF_SkyDom  sk;
    CBspTree*   pMainSky = 0;
    int         nDetails = 0;
    
    CBspTree*   pTree = _bTrees.back();
    
    //
    // there is a main skydom
    //
    sk.skyModelIdx = -1;
    if((pTree->_treeprops & MODEL_IS_SKYDOM) && !(pTree->_treeprops & MODEL_IS_DETAIL))
    {
        sk.skyModelIdx = pTree->_thisIdx;
    }
    
    //
    // now write all details (conut them first)
    //
    
    FOREACH(vvector<CBspTree*>, _bTrees, ppTree)
    {
        pTree = *ppTree;
        if((pTree->_treeprops & MODEL_IS_SKYDOM) && (pTree->_treeprops & MODEL_IS_DETAIL))
          nDetails++;
    }
    sk.subModels = nDetails;
    
    fw.Write(s,"SECT_SKYDOM");
    int start = fw.GetPos();
    
    fw.Write(sk,"BTF_SkyDom");
    //
    // how write indexes of detail models for skydom
    //
    FOREACH(vvector<CBspTree*>, _bTrees, ppTree)
    {
        pTree = *ppTree;
        if((pTree->_treeprops & MODEL_IS_SKYDOM) && (pTree->_treeprops & MODEL_IS_DETAIL))
        {
            fw.Write(pTree->_thisIdx,"index");
        }
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}


void     Compiler::WritItemsCathegory(FlStream& fw)
{
	Scene& scene    = DOC()->_scene;
	BTF_Section     s = {SECT_ITEMCAT, scene.GetCats()->size()};
    fw.Write(s,"SECT_ITEMCAT");
    int start = fw.GetPos();
	
    FOREACH(vvector<ItemCat>, (*scene.GetCats()), pc)
    {
		do{
			int			nIdx = 0;
			int			nOff = 0;
			BTF_ItemCat	bic  = {0};
			
			::strcpy(bic.catName, pc->_catname);
			
			FOREACH(vvector<NameTypeValue>, pc->_classprops, pcp)
			{	
				bic.UserCat.cTypes[nIdx] = (BYTE)pcp->_type;
				::memcpy(&bic.UserCat.byData[nOff], pcp->_value, TypeSize(pcp->_type));

				++nIdx;
				nOff+=TypeSize(pcp->_type);
			}
			bic.nDataLength = nOff;

			fw.Write(bic,"BTF_ItemCat");
		}while(0);
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}


//--|    Compiler::WriteItemsInfo|--------------------------------------------------------
void    Compiler::WriteItemsInfo(map<int,int>& sndidx, map<int,int>& texids ,FlStream& fw)
{
    vvector<SceItem*>* pItems  = _pScene->GetItems();
    
    BTF_Section     s = {SECT_ITEMSINFO, pItems->size()};
    fw.Write(s,"SECT_ITEMSINFO");
    
    int start = fw.GetPos();    

    FOREACH(vvector<SceItem*>, (*pItems), ppItem)
    {
        SceItem* pItem = (*ppItem);
        BTF_Item btItem;
        
        ::memset(&btItem,0,sizeof(btItem));

        ::strcpy(btItem._catname, pItem->_catname);
        ::_tcscpy(btItem._name, pItem->_name);
        btItem._type        = pItem->_item;
        btItem._pos         = pItem->_t;
        btItem._dir         = pItem->_euler;
        btItem._box         = pItem->GetBox();
        btItem._flags       = pItem->_props;
        btItem._areavis     = pItem->_zonearea;

        pItem->GetTexs().GetTextureInts(btItem._texp.textures, btItem._texp.texApply);
        btItem._texp.combine     = pItem->Combine();

        for(int t=0;t<4;t++)
        {
            if(texids.find(btItem._texp.textures[t]) != texids.end())
            {
                btItem._texp.textures[t] = texids[btItem._texp.textures[t]];
                btItem._texp.combine |= (1<<t);
            }
            else
                btItem._texp.textures[t] = -1;
        }
        
        
        // associated sounds for this item
        #pragma message("maxim 254 item sounds per level and 8 per item")

        
        switch(btItem._type)
        {
            case ITM_LIGTBULB:
            {
                CLightBulb* pLb = (CLightBulb*)pItem;
                
                btItem._ligtbulb._specAngle  = pLb->_specAngle;
                btItem._ligtbulb._lmIntensity = pLb->_lmIntensity;
                btItem._ligtbulb._radius  = pLb->_radius;
                btItem._ligtbulb._halloRadMin = pLb->_halloRadMin;
                btItem._ligtbulb._halloRadMax = pLb->_halloRadMax;
                btItem._ligtbulb._colorD[0]      = pLb->_colorD.r;
                btItem._ligtbulb._colorD[1]      = pLb->_colorD.g;
                btItem._ligtbulb._colorD[2]      = pLb->_colorD.b;
                btItem._ligtbulb._colorD[3]      = pLb->_colorD.a;

                btItem._ligtbulb._colorE[0]      = pLb->_colorE.r;
                btItem._ligtbulb._colorE[1]      = pLb->_colorE.g;
                btItem._ligtbulb._colorE[2]      = pLb->_colorE.b;
                btItem._ligtbulb._colorE[3]      = pLb->_colorE.a;

                btItem._ligtbulb._colorS[0]      = pLb->_colorS.r;
                btItem._ligtbulb._colorS[1]      = pLb->_colorS.g;
                btItem._ligtbulb._colorS[2]      = pLb->_colorS.b;
                btItem._ligtbulb._colorS[3]      = pLb->_colorS.a;

                btItem._ligtbulb._attenuation[0]= pLb->_atten[0];
                btItem._ligtbulb._attenuation[1]= pLb->_atten[1];
                btItem._ligtbulb._attenuation[2]= pLb->_atten[2];
                
                fw.Write(btItem, "BTF_Item");
            }
            break;
            case ITM_STARTPLAY:
            {
                CStartPlayItem* spi = (CStartPlayItem*)pItem;
                if(spi->_team.length())
                    _tcscpy(btItem._startitem._team, spi->_team.c_str());
                else
                    btItem._startitem._team[0]=0;
                fw.Write(btItem, "BTF_Item");
            }
            break;
            case ITM_TRIGER:
            {
                TriggerItem* pTr = (TriggerItem*)pItem;
                
                btItem._trigger._brushIndex = pTr->_brIndex;
                
                fw.Write(btItem, "BTF_Item");
            }
            break;
            case ITM_GAME:
            {
                GameItem* pGi = (GameItem*)pItem;
                int		  j=0;
				int		  offset = 0;

                FOREACH(vvector<NameTypeValue>,  pGi->_data, pntv)
                {
                    btItem._gameitem._type[j] = pntv->_type;
                    ::memcpy(&btItem._gameitem._buff[offset],
							 pntv->_value,
							 TypeSize(pntv->_type));
                    ++j;
					offset+=TypeSize(pntv->_type);
                    assert(j<16);
                }

				fw.Write(btItem, "BTF_Item");
            }
            break;
            default:
            break;
        }
    }
    #pragma message(" SECT_ITEMS_INFO_CUST")
    // SECT_ITEMS_INFO_CUST
    KeepSecttions(start,fw.GetPos(), s, fw);
}

void    Compiler::WriteZones(FlStream& fw)
{
    BTF_Section   s = {SECT_ZONES, _zonecount};
    fw.Write(s,"SECT_ZONES");
    int start = fw.GetPos();

    BTF_Zone    zone;
    Brush** pHead = _zones;
    while(*pHead)
    {
        zone.box      = (*pHead)->_box;
        zone.visData  = (*pHead)->VisData();
        zone.reserved = (*pHead)->ZoneIdx();
        fw.Write(zone,"BTF_Zone");
        ++pHead;
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
    return ;
}

//--|    Compiler::WriteMotions|----------------------------------------------------------
void    Compiler::WriteMotions(FlStream& fw)
{
    BTF_Motion      btMotion;
    BTF_MotionNode  btMotionNode;
    
    ASSERT(_pScene);
    vvector<CMotion*>* pMotions =  _pScene->GetMotions();
    
    BTF_Section     s = {SECT_MOTION, pMotions->size()};
    fw.Write(s,"SECT_MOTION");
    int start = fw.GetPos();
    
    FOREACH(vvector<CMotion*>,  (*pMotions), ppMotion)
    {
        CMotion* pMotion = *ppMotion;
        
        btMotion.cntNodes   = pMotion->GetNodesCount();
        btMotion.modelIndex = -1;// taken from models
        btMotion.flags      = pMotion->IsLoop() ? M_LOOP: M_OPEN;
        fw.Write(btMotion,"BTF_Motion");
        for(int i=0;i<btMotion.cntNodes;i++)
        {
            MState* pState = pMotion->GetState(i);
            
            btMotionNode.pauseTime  = pState->_trTimes[0];
            btMotionNode.trTime     = pState->_trTimes[1];
            btMotionNode.vPos       = pState->_pos;
            btMotionNode.vDir       = pState->_euler;
            btMotionNode.flags      = 0;
            
            fw.Write(btMotionNode,"BTF_MotionNode");
        }
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}


//--| |------------------------------------------------------------
void Compiler::WriteTerrain(FlStream& fw, map<int,int>& texids)
{
    if(!_terrTree.Exist())
        return;
    BTF_Terrain_Tree     bt;
    BTF_Section     s     = {SECT_TERRAIN, 1};
    CBigTerrain&    bigT  =  *_terrTree.p_Terrain;
    Poly&           poly  = _terrTree.p_Terrain->p_dummyBrush->FirstPoly();
    fw.Write(s,"SECT_TERRAIN");
    int  start       = fw.GetPos();

    ((Poly&)poly).GetTexs().GetTextureInts(bt._texp.textures, bt._texp.texApply);
    bt._texp.combine = poly.Combine();

    for(int t=0;t<4;t++)
    {
        if(texids.find(bt._texp.textures[t]) != texids.end())
        {
            bt._texp.textures[t] = texids[bt._texp.textures[t]];
            bt._texp.combine |= (1<<t);
        }
        else
            bt._texp.textures[t] = -1;
    }
    

    bt.flags        = bigT.Flags();      
    bt.colorS       = poly._colorS;      
    bt.colorD       = poly._colorD;      
    bt.colorE       = poly._colorE;      
    bt.shiness      = poly._shiness;     
    bt.bump         = poly._bump*100;        
    bt.friction     = poly._friction*100;    
    bt.box          = bigT.b_box;
    bt.tiles[0]     = bigT.n_xtiles;
    bt.tiles[1]     = bigT.n_ztiles;
    bt.heightMap    = bigT.v_vxes.Size();
    bt._stage       = bigT.n_stage;
    bt._tanim[0]    = bigT.t_anim[0];
    bt._tanim[1]    = bigT.t_anim[1];
    
    if(_bSaveBigTerrainBSP)
    {
        // TERRAIN        
        bt.gouraud       = _terrTree.g_light.size();
        bt.nodes         = _terrTree.p_nodes.size();
        bt.leafs         = _terrTree.p_leafs.size(); 
        bt.flags         = _terrTree.x_flags;

        bt.tiles[0]      = bigT.n_xtiles;
        bt.tiles[1]      = bigT.n_ztiles;
        bt.box           = bigT.p_dummyBrush->_box;
        
        fw.Write(bt, "BTF_Terrain_Tree");
        // vxes
        int   nVxes = 0;
        BYTE* pVxes = bigT.Vertextex(nVxes);
        fw.Write(pVxes, nVxes);

        KeepSecttions(start,fw.GetPos(), s, fw);

        // TERR GLIGHT IF ANY
        BTF_Section  s1  = {SECT_TERRAINGLIGHT, _terrTree.g_light.size()};
            fw.Write(s1,"SECT_TERRAINGLIGHT");
            start       = fw.GetPos();
            //goround light 
            if(_terrTree.g_light.size())
            {
                CLRNOA*  pClr   = &_terrTree.g_light[0];
                fw.Write(pVxes, nVxes*sizeof(CLRNOA));
            }
        KeepSecttions(start,fw.GetPos(), s1, fw);

        // TERR NODES
        BTF_Section  s2  = {SECT_TERRAINNODES, _terrTree.p_nodes.size()};
            fw.Write(s2,"SECT_TERRAINNODES");
            start  = fw.GetPos();
            TerNode*            pWalk;
            BTF_Terrain_Node    btn;
            FOREACH(vvector<TerNode*>, _terrTree.p_nodes, ppnode)
            {
                pWalk = *ppnode;
            
                btn.bbox        = pWalk->b_box;
                btn.lidx        = pWalk->l_idx;
                btn.dsplit      = pWalk->d_split;
                btn.inodes[0]   = pWalk->i_nodes[0];    
                btn.inodes[1]   = pWalk->i_nodes[1];
                btn.iparentNode = pWalk->i_parentNode;
                fw.Write(btn, "BTF_Terrain_Node");
            }
        KeepSecttions(start,fw.GetPos(), s2, fw);

        // TERR LEAFS
        BTF_Section  s3  = {SECT_TERRAINLEAFS, _terrTree.p_leafs.size()};
        fw.Write(s3,"SECT_TERRAINLEAFS");
        start  = fw.GetPos();
        TerLeaf*            pLeaf;
        BTF_Terrain_Leaf    blt;
        FOREACH(vvector<TerLeaf*>, _terrTree.p_leafs, ppleaf)
        {
            pLeaf = *ppleaf;

            blt.nidx         = pLeaf->n_idx;
            blt.tiles[0]     = pLeaf->s_tiles[0].cx;
            blt.tiles[1]     = pLeaf->s_tiles[0].cy;
            blt.tiles[2]     = pLeaf->s_tiles[1].cx;
            blt.tiles[3]     = pLeaf->s_tiles[1].cy;
            blt.lightMapInfo = pLeaf->lm_info._lmIndex;
            blt.xflags       = pLeaf->x_flags;
            blt.userVals[0]  = pLeaf->lm_info._size.cx;
            blt.userVals[1]  = pLeaf->lm_info._size.cy;
            fw.Write(blt, "BTF_Terrain_Leaf");
        }
        KeepSecttions(start,fw.GetPos(), s3, fw);
       
    }
    else
    {
        bt.gouraud      = 0;
        bt.nodes        = 0;
        bt.leafs        = 0; 

        bt.tiles[0]      = bigT.n_xtiles;
        bt.tiles[1]      = bigT.n_ztiles;
        bt.box           = bigT.p_dummyBrush->_box;
        bt.flags         = bigT.Flags();

        fw.Write(bt, "BTF_Terrain_Tree");
        int   nVxes = 0;
        BYTE* pVxes = bigT.Vertextex(nVxes);
        fw.Write(pVxes, nVxes*sizeof(BYTE));
        KeepSecttions(start,fw.GetPos(), s, fw);
    }
    
}

//--| |------------------------------------------------------------
void Compiler::WriteDetails(FlStream& fw)
{
    map<string ,string>& descs      = SCENE().Descriptions();
    int                  ndetails   = descs.size();
    BTF_Section          s          = {SECT_DETAILS, ndetails};
    BTF_Details          detcell; 

    fw.Write(s,"SECT_DETAILS");
    int start = fw.GetPos();
    for(map<string ,string>::iterator b = descs.begin(); b != descs.end(); b++)
    {
        SCopy(detcell.name, (char*)(*b).first.c_str(), sizeof(detcell.name));
        detcell.length = (*b).second.length();
        fw.Write(detcell,"BTF_Details");
        fw.WriteTextAsIs((*b).second.c_str());
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}

void Compiler::WriteRandomBits(FlStream& fw)
{
    // cals the length of this section
    unsigned long rbsize = 0;
    FOREACH(vvector<SBytes*>, _randombytes ,rb) 
    {
        if((*rb)->size < 0 && _bSaveImages) // filre reference
        {
            switch((*rb)->stype)
            {
                case SBytes::S_IMAGE:
                    {
                        TexHandler th;
                        th.LoadThisFile((const char*)(*rb)->ptr,0);
                        rbsize+=th.GetImgSize();
                        th.Reset();
                    }
                    break;
                default: 
                    {
                        FileWrap fw;
                        if(fw.Open((const char*)(*rb)->ptr,"rb"))
                        {
                            rbsize+=fw.Getlength();
                            fw.Close();
                        }
                    }
                    break;
            }
        }
        else
            rbsize+=::abs((*rb)->size); //raw data is already here
    }


    int                  nbytes     = rbsize;
    BTF_Section          s          = {SECT_RANDOMBYTES, nbytes};

    fw.Write(s,"SECT_RANDOMBYTES");
    int start = fw.GetPos();

    FOREACH(vvector<SBytes*>, _randombytes ,rb) 
    {
        SBytes* pbys = *rb;
        if(pbys->size < 0 && _bSaveImages) // file reference
        {
            switch(pbys->stype)
            {
            case SBytes::S_IMAGE:
                {
                    TexHandler th;
                    th.LoadThisFile((const char*)(pbys->ptr),0);
                    fw.Write(th.Buffer(), th.n_size);
                    th.Reset();
                }
                break;
            default: 
                {
                    size_t   rb;
                    BYTE     loco[255];
                    FileWrap fw;
                    if( fw.Open( (char*) (pbys->ptr),"rb" ) )
                    {
                        while(!fw.IsEof())
                        {
                            rb = fw.Read(loco, 255);
                            if(rb>0)
                                fw.Write(loco, rb);
                        }
                        if(fw.IsEof())break;
                    }
                    fw.Close();
                }
            }
            break;
        }
        else
            fw.Write(pbys->ptr, ::abs(pbys->size));
    }
    KeepSecttions(start,fw.GetPos(), s, fw);
}


//--| Compiler::KeepSecttions|------------------------------------------------------------
void Compiler::KeepSecttions(DWORD nstart, DWORD nend, BTF_Section& s, FlStream& fw)
{
    s._bytes = nend - nstart;
    fw.Pos((nstart-sizeof(BTF_Section)), SEEK_SET);
    fw.Write(s);
    fw.Pos(nend, SEEK_SET);
}

//--| __MakeZipExtension|-----------------------------------------------------------------
static void  __MakeZipExtension(LPCTSTR bspNameFinal, PTSTR bspNameFinalZ, LPCTSTR ext)
{
    ::_tcscpy(bspNameFinalZ, bspNameFinal);
        char* pdot = _tcschr(bspNameFinalZ,'.');
    if(pdot) (*pdot) = 0;
    ::_tcscat(bspNameFinalZ,ext); // bsp zip
}

//--| _HookCopyFile|----------------------------------------------------------------------
static BOOL  _CompressZip(LPTSTR bspNameFinal, LPCTSTR ext)
{
    char	bspNameFinalZ[_MAX_PATH];

    __MakeZipExtension(bspNameFinal,bspNameFinalZ,ext); 
    BOOL ok=FALSE; 
    _TRY
    {
        CBzipCompressor cc(bspNameFinalZ);
        cc.AddFile(bspNameFinal); 
        if(!cc.Process(1))
        {
            AfxMessageBox(MKSTR("Cannot compress '%s' \r\n into \r\n '%s'", bspNameFinal, bspNameFinalZ),MB_ICONWARNING|MB_OK);
        }
        else
            ok=TRUE;
    }
    _CATCHX()
    {
        AfxMessageBox(MKSTR("Cannot compress '%s' \r\n into \r\n '%s'", bspNameFinal, bspNameFinalZ),MB_ICONWARNING|MB_OK);
    }
    if(ok)
    {
        DeleteFile(bspNameFinal);
        ::_tcscpy(bspNameFinal, bspNameFinalZ);
    }
    return ok;
}

//--| _HookCopyFile|----------------------------------------------------------------------
static DWORD _GetFileSize(LPCTSTR fName)
{
    DWORD fsz = INVALID_FILE_SIZE;
    HANDLE hFile = CreateFile(fName, GENERIC_READ, 0, NULL, OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        fsz = GetFileSize(hFile, NULL);
        ::CloseHandle(hFile);
    }
    return fsz;
}

//--| _HookCopyFile|----------------------------------------------------------------------
// if file exist in common ! copy it
static BOOL  _HookCopyFile(LPCTSTR scrDir,  LPCTSTR fName, 
                           LPCTSTR destDir, LPTSTR dstFullName)
{
    char   scrFullName[_MAX_PATH];

    ::_stprintf(scrFullName, "%s%s", scrDir, fName);
    ::_stprintf(dstFullName, "export\\common\\%s", fName);

    char* pqm = strchr(scrFullName,'?'); if(pqm)*pqm=0;
    pqm = strchr(dstFullName,'?'); if(pqm)*pqm=0;
    
    DWORD srcDim = _GetFileSize(scrFullName);
    DWORD dstDim = _GetFileSize(dstFullName);

    if(INVALID_FILE_SIZE == srcDim)
        return 0;

    if(dstDim != INVALID_FILE_SIZE) 
    {
        if(dstDim == srcDim)        // already there
        {
            return 1;
        }
        else                        // copy in destDir
        {
            ::_stprintf(dstFullName, "export\\%s\\%s", destDir, fName);
        }
    }
    return ::CopyFile(scrFullName,  dstFullName, 0);
}


//--| Compiler::Export|-------------------------------------------------------------------
void Compiler::Export(const char* bspFile)
{
    REDIR();
	char	xmlFname[_MAX_PATH];
	char	newDirName[_MAX_PATH];
	char	bspNameFinal[_MAX_PATH];
    char	destLocationFname[_MAX_PATH];
    DWORD   flength;

    vvector<tstring>     dependencies;
    vvector<DWORD>       lengths;

    PathHandler phBsp(bspFile);

    
	::mkdir("export");
    ::mkdir("export\\common"); // all common files. if found then copy in particular subfolder
	::_stprintf(newDirName,"export\\%s",phBsp.JustFile());
	::mkdir(newDirName);

	::_stprintf(bspNameFinal,"%s\\%s",newDirName, phBsp.File());
    ::CopyFile(bspFile,bspNameFinal,0);

    if(_szipit)
    {
        _CompressZip(bspNameFinal,".gbz");
    }
    lengths << _GetFileSize(bspNameFinal);

    if(!_bSaveImages)
    {
        // compres textures too
        TexSys::iterator bt = GTexSys.begin();
        TexSys::iterator et = GTexSys.end();
        for(;bt != et; bt++)
        {
            Texture& tex  = (*bt).second;
    
            if((*bt).first.find('.') != -1)
            {
                PathHandler ph((*bt).first.c_str());

                if(::_HookCopyFile("res\\", ph.File(), phBsp.JustFile(), destLocationFname))
                {
                    if(_szipit)
                        _CompressZip(destLocationFname,".gtz");
                    {
                        flength = _GetFileSize(destLocationFname);

                        char *pStart = _tcsstr(destLocationFname,"export\\")+_tcslen("export\\");
                        Replace(pStart, '\\', '/');
                        dependencies << pStart;
                        lengths << flength;
                    }
                }
            }
        }
    }

    if(!_bSaveImages)
    {
        FOREACH(vvector<CSoundItem*>, (*DOC()->_scene.GetSounds()), ppSi)
        {
            CSoundItem* psi = *ppSi;
            PathHandler ph(psi->_soundfile.c_str());

            if(::_HookCopyFile("res\\", ph.File(), phBsp.JustFile(), destLocationFname))
            {
                if(_szipit)
                    _CompressZip(destLocationFname,".gsz");
                {
                    flength = _GetFileSize(destLocationFname);
                    char *pStart = _tcsstr(destLocationFname,"export\\")+_tcslen("export\\");
                    Replace(pStart, '\\', '/');
                    dependencies << pStart;
                    lengths << flength;
                }
            }
        }
    }
	
    if(!_bSaveImages)
    {
        FOREACH(vvector<ScriptItem*> , (*DOC()->_scene.GetScripts()), ppSi)
        {
            ScriptItem* psi = *ppSi;
            PathHandler ph(psi->_script.c_str());

            if(::_HookCopyFile("res\\", ph.File(), phBsp.JustFile(), destLocationFname))
            {
                if(_szipit)
                    _CompressZip(destLocationFname,".gcz");
                {
                    flength = _GetFileSize(destLocationFname);

                    char *pStart = _tcsstr(destLocationFname,"export\\")+_tcslen("export\\");
                    Replace(pStart, '\\', '/');
                    dependencies << pStart;
                    lengths << flength;
                }
            }
        }
    }
	
    if(!_bSaveImages) // from items
    {
    }
    
	::_stprintf(xmlFname,"export\\%s.ml",phBsp.JustFile());
	WriteXML(xmlFname, bspNameFinal, phBsp.JustFile(), dependencies, lengths);
    UpdateServerIndex();
}

void	Compiler::WriteXML(const char *xmlFname, const 
                           char* bspNameFinalZ, 
                           const char* subDir, 
                           vvector<tstring>& dependencies,
                           const vvector<DWORD>& lengths)
{
	PathHandler phBsp(bspNameFinalZ);
    FlStream    fw;
    fw.Open(xmlFname,"wb");
    fw.WriteTextAsIs("<xml>\r\n");
    // main bsp
    fw.WriteTextAsIs("<getic type='level' version='200'>\r\n");
    int inxLength=1;
    fw.WriteTextAsIs(MKSTR("\t<file url='%s/%s' length='%d' type='bsp' />\r\n", phBsp.JustFile(), phBsp.File(), lengths[0]));

    FOREACH(vvector<tstring>, dependencies, dep)
    {
        fw.WriteTextAsIs(MKSTR("\t<file url='%s' length='%d' type='res' />\r\n", (*dep).c_str(), lengths[inxLength]));
        ++inxLength;
        
    }
    fw.WriteTextAsIs("</getic>\r\n");
    fw.WriteTextAsIs("</xml>\r\n");
    fw.Close();

}

//--|     Compiler::ExportBSP|------------------------------------------------------------
BOOL     Compiler::ExportBSP(LPCTSTR pFIleName)
{
    return 1;
}

void Compiler::UpdateServerIndex()
{
	HANDLE			hfFind;
	WIN32_FIND_DATA	fDATA;	
    char           cwd[260];

    ::_getcwd(cwd, 260);
    if(!strstr(cwd,"export"))
    {
        ::chdir("export");
    }

    FlStream    fw;
    if(fw.Open("getic_index.ml","wb"))
    {
        fw.WriteTextAsIs("<xml>\r\n");
        fw.WriteTextAsIs("<getic type='index' version='200' >\r\n");
	    if((hfFind=FindFirstFile("*.ml", &fDATA)) != INVALID_HANDLE_VALUE)
	    {

		    if(!(fDATA.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && fDATA.cFileName[0]!='.')
		    {
                if(strcmp(fDATA.cFileName,"getic_index.ml"))
                    fw.WriteTextAsIs(MKSTR("\t<file url='%s' length='%d' type='ml'/>\r\n",fDATA.cFileName, fDATA.nFileSizeLow ));
            }
		    while(FindNextFile(hfFind, &fDATA)!=0)
		    {
			    if(!(fDATA.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && fDATA.cFileName[0]!='.')
                {
                    if(strcmp(fDATA.cFileName,"getic_index.ml"))
                        fw.WriteTextAsIs(MKSTR("\t<file url='%s' length='%d' type='ml'/>\r\n",fDATA.cFileName, fDATA.nFileSizeLow ));
                }
		    }
	    }
	    FindClose(hfFind);  
        fw.WriteTextAsIs("</getic>\r\n");
        fw.WriteTextAsIs("</xml>\r\n");
        fw.Close();
    }
    _chdir(cwd);
}
